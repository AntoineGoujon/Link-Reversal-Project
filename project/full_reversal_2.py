# -*- generated by 1.0.13 -*-
import da
PatternExpr_202 = da.pat.ConstantPattern('REVERSE')
PatternExpr_206 = da.pat.FreePattern('u')
PatternExpr_232 = da.pat.ConstantPattern('NOP')
PatternExpr_236 = da.pat.FreePattern('u')
PatternExpr_246 = da.pat.ConstantPattern('ACK')
PatternExpr_250 = da.pat.FreePattern('u')
_config_object = {'channel': 'reliable'}

class Agent(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_AgentReceivedEvent_0', PatternExpr_202, sources=[PatternExpr_206], destinations=None, timestamps=None, record_history=None, handlers=[self._Agent_handler_201]), da.pat.EventPattern(da.pat.ReceivedEvent, '_AgentReceivedEvent_1', PatternExpr_232, sources=[PatternExpr_236], destinations=None, timestamps=None, record_history=None, handlers=[self._Agent_handler_231]), da.pat.EventPattern(da.pat.ReceivedEvent, '_AgentReceivedEvent_2', PatternExpr_246, sources=[PatternExpr_250], destinations=None, timestamps=None, record_history=None, handlers=[self._Agent_handler_245])])

    def setup(self, neighbors_out, neighbors_in, isDestination, **rest_566):
        super().setup(neighbors_out=neighbors_out, neighbors_in=neighbors_in, isDestination=isDestination, **rest_566)
        self._state.neighbors_out = neighbors_out
        self._state.neighbors_in = neighbors_in
        self._state.isDestination = isDestination
        self._state.msg_counter = 0
        self._state.ack_counter = 0
        self._state.neighbors = (self._state.neighbors_in + self._state.neighbors_out)
        self._state.nNeighbors = len(self._state.neighbors)
        self._state.l = []

    def run(self):
        while True:
            if (not (self._state.nNeighbors == len(self._state.neighbors))):
                self.output(f'n: {self._state.nNeighbors}=={len(self._state.neighbors)}')
            may_reverse = ((not self._state.isDestination) and (len(self._state.neighbors_out) == 0))
            if may_reverse:
                for v in self._state.neighbors:
                    self.send('REVERSE', to=v)
                    self._state.l.append(v)
            else:
                for v in self._state.neighbors:
                    self.send('NOP', to=v)
            super()._label('_st_label_329', block=False)
            _st_label_329 = 0
            while (_st_label_329 == 0):
                _st_label_329 += 1
                if (self._state.msg_counter == self._state.nNeighbors):
                    _st_label_329 += 1
                else:
                    super()._label('_st_label_329', block=True)
                    _st_label_329 -= 1
            else:
                if (_st_label_329 != 2):
                    continue
            if (_st_label_329 != 2):
                break
            self._state.msg_counter = 0
            if may_reverse:
                self._state.neighbors_in = []
                self._state.neighbors_out = self._state.neighbors
                for v in self._state.l:
                    self._state.neighbors_in.remove(v)
                    self._state.neighbors_out.append(v)
            else:
                for v in self._state.l:
                    self._state.neighbors_out.remove(v)
                    self._state.neighbors_in.append(v)
            self._state.l = []
            for v in self._state.neighbors:
                self.send('ACK', to=v)
            super()._label('_st_label_412', block=False)
            _st_label_412 = 0
            while (_st_label_412 == 0):
                _st_label_412 += 1
                if (self._state.ack_counter == self._state.nNeighbors):
                    _st_label_412 += 1
                else:
                    super()._label('_st_label_412', block=True)
                    _st_label_412 -= 1
            else:
                if (_st_label_412 != 2):
                    continue
            if (_st_label_412 != 2):
                break
            self._state.ack_counter = 0

    def _Agent_handler_201(self, u):
        assert (u in self._state.neighbors_out)
        assert (not (u in self._state.neighbors_in))
        self._state.l.append(u)
        self._state.msg_counter += 1
    _Agent_handler_201._labels = None
    _Agent_handler_201._notlabels = None

    def _Agent_handler_231(self, u):
        self._state.msg_counter += 1
    _Agent_handler_231._labels = None
    _Agent_handler_231._notlabels = None

    def _Agent_handler_245(self, u):
        self._state.ack_counter += 1
    _Agent_handler_245._labels = None
    _Agent_handler_245._notlabels = None

class Node_(da.NodeProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._events.extend([])

    def run(self):
        graph = [[0, 0, 0, 0, 0, 1, 0], [1, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0, 0], [0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0]]
        N = len(graph[0])
        agents = list(self.new(Agent, num=N))
        for k in range(N):
            neighbors_in = [agents[i] for i in range(N) if (graph[k][i] == 1)]
            neighbors_out = [agents[i] for i in range(N) if (graph[i][k] == 1)]
            self._setup(agents[k], (neighbors_out, neighbors_in, (k == 6)))
        self._start(agents)
